# MySQL 数据库规范

# 1. 规范背景与目的

MySQL 数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用 MySQL 数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导 RD、QA、OP 等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL 编写等方面予以规范。


# 2. 设计规范

## 2.1 数据库设计

以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。


### 2.1.1 一般命名规则

1. 【强制】命名只能使用小写、下划线和数字，禁止只用数字，禁止两个下划线中间只有数字。

2. 【强制】命名要能做到见名识意，并且最好不要超过 32 个字符。

3. 【强制】命名禁止使用 `MySQL` 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来），可以为这些名称添加前缀使其易于理解，如 `user_name`，`signup_date` 等。

4. 【强制】命名使用单数。


### 2.1.2 库

1. 【强制】遵守以上全部一般命名规则。

2. 【强制】库的名称格式：业务系统名称_子系统名。

3. 【强制】一般分库名称命名格式是`库通配名_编号`，编号从 0 开始递增，比如 `northwind_001`，以时间进行分库的名称格式是`库通配名_时间`。

4. 【强制】创建数据库时必须显式指定字符集，并且字符集只能是 utf8 或者 utf8mb4。创建数据库 SQL 举例：
    ```sql
    create database db_name default character set utf8;
    ```


### 2.1.3 表

1. 【强制】遵守以上全部一般命名规则。

2. 【强制】相关模块的表名与表名之间尽量体现 join 的关系，如 `user` 表和 `user_login` 表。

3. 【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。

4. 【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为 InnoDB。
    当需要使用除 InnoDB/MyISAM/Memory 以外的存储引擎时，必须通过 DBA 审核才能在生产环境中使用。
    因为 InnoDB 表支持事务、行锁、宕机恢复、MVCC 等关系型数据库重要特性，为业界使用最多的 MySQL 存储引擎。而这是其它大多数存储引擎不具备的，因此首推 InnoDB。

5. 【强制】建表必须有 comment。

6. 【强制】中间表用于保留中间结果集，名称必须以 `tmp_` 开头。备份表用于备份或抓取源表快照，名称必须以 `bak_` 开头。中间表和备份表应以日期 (时间戳) 为后缀。中间表和备份表定期清理。

7. 【强制】对于超过 100W 行的大表进行 `alter table`，必须经过 DBA 审核，并在业务低峰期执行。
    因为 `alter table` 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。

8. 【建议】尽量控制单表的数据量在 500 万以内。

9. 【建议】尽量做到冷热数据分离,减小表的宽度。`MySQL` 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。
    - 减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；
    - 更有效的利用缓存，避免读入无用的冷数据；
    - 经常一起使用的列放到一个表中（避免更多的关联操作）。

10. 【强制】禁止在数据库中存储图片,文件等大的二进制数据。
    - 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。
    - 通常存储于文件服务器，数据库只存储文件地址信息


### 2.1.4 字段

1. 【强制】遵守以上全部一般命名规则。

2. 【建议】尽可能选择短的或一两个单词。

3. 【强制】避免使用与表名相同的字段名，这会在编写查询时造成混淆。

4. 【强制】在数据库模式上定义外键。外键列必须具有表名及其主键，例如：`blog_id` 表示来自表博客的主键 id。

5. 【建议】表中所有字段必须都是 `NOT NULL` 属性，字符类型默认为 ''，数字类型默认为 0。
    因为使用 `NULL` 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。
    下面摘自MySQL自己的文档：
    > “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”

6. 【强制】不同表所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

7. 【强制】关于主键：
    (1) 为每张表设置一个ID，命名为 `id`，类型为 int 或 bigint，且为 `auto_increment`，推荐使用`UNSIGNED`；另外，在你的程序中，你应该使用表的ID来构造你的数据结构。而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要。
    (2) 标识表里每一行主体的字段不要设为主键，建议设为其它字段如 `user_id`，`order_id`等，并建立 `unique key` 索引。因为如果设为主键且主键值为随机插入，则会导致 InnoDB 内部 page 分裂和大量随机 I/O，性能下降。

8. 【强制】每行记录必须有：创建时间字段 `create_at` 和最后更新时间字段 `update_at`，如果有软删除，则增加 `deleted_at`。所有时间类型的字段，以 `_at` 结尾。

9. 【建议】建议对表里的 `blob`、`text` 等大字段，垂直拆分到其它表里，仅在需要读这些对象的时候才去 select。
    `blob`，`text` 它们都比较浪费硬盘和内存空间。如果用`TEXT` 或 `BLOB` 类型只能使用前缀索引。
    在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。
    InnoDB 中当一行记录超过 8098 字节时，会将该记录中选取最长的一个字段将其 768 字节放在原始 page 里，该字段余下内容放在 `overflow-page` 里。不幸的是在 `compact` 行格式下，原始 `page` 和 `overflow-page` 都会加载。

10. 【建议】反范式设计：把经常需要 join 查询的字段，在其它表里冗余一份。
    如 `username` 属性在 `user_account`，`user_login_log` 等表里冗余一份，减少 join 查询。


### 2.1.5 字段数据类型优化

1. 【建议】表中的自增列（`auto_increment` 属性），推荐使用 `bigint` 类型。因为无符号 `int` 存储范围为 `0~4,294,967,295`（不到 43 亿），溢出后会导致报错。

2. 【建议】业务中选择性很少的状态 `status`、类型 `type` 等字段推荐使用 `tinytint` 或者 `smallint` 类型节省存储空间。

3. 【建议】业务中 IP 地址字段推荐使用 `int` 类型，不推荐用 `char(15)`。因为 `int` 只占 4 字节，可以用如下函数相互转换，而 `char(15)` 占用至少 15 字节。
    如果在IP字段添加索引则不推荐,因为使用函数转化后，索引会失效。
    ```sql
    select inet_aton('13.107.21.200');
    select inet_ntoa(225121736); 
    ```

4. 【建议】枚举 `enum`，`set` 和 `tinyint` 或 `smallint`的选择，看具体场景。
    枚举：
    缺点：枚举值写死了，变更不方便。
    优点：ENUM类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。

    tinyint` 或 `smallint`：
    缺点： 
        - 表达不清：如果对相关字段定义理解不是特别深的话，每次都需要去看字段注释，甚至有时候在编码的时候需要去数据库确认字段含义。
        - 脏数据：虽然在应用层可以通过代码限制插入的数值，但是还是可以通过 SQL 和可视化工具修改值。
    优点：灵活
        
    这种固定选项值的字段，推荐使用 `enum` 枚举字符串类型，外加 SQL_MODE 的严格模式。
    在 MySQL 8.0.16 以后的版本，可以直接使用 CHECK 约束机制，不需要使用 `enum` 枚举类型。

5. 【建议】尽量使用数字型字段、若只含数值信息的字段尽量不要设计为字符型、这会降低查询和连接的性能、并会增加存储开销。
    这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符、而对于数字型而言只需要比较一次就够了。

6. 【建议】存储金额的字段，建议用 `int` 类型以「分」而不是「元」为单位存储，存储千兆级别的金额可以使用 `bigint` 类型，程序端乘以 100 和除以 100 进行存取，如 1 元在数据库中用整型类型 100 存储。
    不建议使用 `decimal` 类型存储金额，`decimal` 是通过二进制实现的一种编码方式，计算效率不如整型。
    使用整型的字段是定长字段，存储高效，而 `decimal` 根据定义的宽度决定，在数据库设计中，定长存储更高效。

7. 【建议】`char` 和 `varchar`
    - 文本数据尽量用 `varchar` 存储。因为 `varchar` 是变长存储，比 `char` 更省空间。
    - 如果存储的字符串长度几乎相等，使用 `char` 定长字符串类型。 从优化角度来说，如果一个表的所有字段都是定长的，那么每一条数据也就是定长的，数据库就可以直接计算出下一条数据的偏移量，查询速度会更快。
    - MySQL server 层规定一行所有文本最多存 65535 字节，因此在 utf8 字符集下最多存 21844 个字符，超过会自动转换为 `mediumtext` 字段。而 `text` 在 utf8 字符集下最多存 21844 个字符，`mediumtext` 最多存 2^24/3 个字符，`longtext` 最多存 2^32 个字符。一般建议用 `varchar` 类型，字符数不要超过 2700。

8. 【建议】时间类型尽量选取 `timestamp`， 次选 `datetime` 。
    - `timestamp` 占用 4 字节和 INT 相同，但比 INT 可读性高，存储的时间范围 `1970-01-01 00:00:01` 到 `2038-01-19-03:14:07`
    - `datetime` 占用 8 字节，超出 `timestamp` 取值范围的使用 `datetime` 类型存储，需要精确到毫秒用 DATETIME(6)。
    - 不推荐选用 `int` 来存储时间，使用 SQL 函数 `unix_timestamp()` 和 `from_unixtime()` 来进行转换，会导致索引不可用。
    
* 详细存储大小参考下图：

    | 类型（同义词）                              | 存储长度(BYTES) | 最小值(SIGNED/UNSIGNED) | 最大值(SIGNED/UNSIGNED)|
    |---------------------------------------------|--------|---------------------|------------------------|
    | *整形数字*                                  |        |                     |                        |
    | TINYINT                                     | 1      | -128/0              | 127/255                 |
    | SMALLINT                                    | 2      | -32,768/0           | 32767/65,535           |
    | MEDIUMINT                                   | 3      | -8,388,608/0        | 8388607/16,777,215/      |
    | INT(INTEGER)                                | 4      | -2,14,7483,648/0    | 2147483647/4,294,967,295/ |
    | BIGINT                                      | 8      | -2^63/0             |    2^63-1/2^64-1 |
    | *小数支持*                                  |        |                     |                        |
    | FLOAT[(M[,D])]                             | 4 or 8  | -                   |                        |
    | DOUBLE[(M[,D])]<br>(REAL, DOUBLE PRECISION)| 8       | -                   |                        |
    | *时间类型*                                  |        |                     |                        |
    | DATETIME                                    | 8      | 1001-01-01 00:00:00 | 9999-12-31 23:59:59    |
    | DATE                                        | 3      | 1001-01-01          | 9999-12-31             |
    | TIME                                        | 3      | 00:00:00            | 23:59:59               |
    | YEAR                                        | 1      | 1001                | 9999                   |
    | TIMESTAMP                                   | 4      | 1970-01-01 00:00:00 |                        |


### 2.1.6 索引设计

1. 【强制】InnoDB 表必须主键为 `id int/bigint auto_increment`，且主键值禁止被更新。

2. 【建议】主键索引的名称以 `pk_` 开头，唯一索引以 `uk_` 开头，普通索引以 `idx_` 开头，一律使用小写格式，以表名/字段的名称或缩写作为后缀。

3. 【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 `BTREE`；MEMORY 表可以根据需要选择 `HASH` 或者 `BTREE` 类型索引。

4. 【强制】单个索引中每个索引记录的长度不能超过 64KB。

5. 【建议】单个表上的索引个数不能超过 5 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
    - 反方意见：MySQL 单表的索引没有个数限制，业务查询有具体需要即可即可，不要迷信个数限制。
    - 正方意见：索引并不是越多越好、索引固然可以提高相应的 select 的效率、但同时也降低了 insert 及 update 的效率、因为 insert 或 update 时有可能会重建索引。
    - 所以怎样建索引需要慎重考虑、视具体情况而定。

6. 【建议】索引列的选择
    - 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
    - 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
    - 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
    - 多表 join 的关联列。这样，MySQL内部会启动为你优化Join的SQL语句的机制。而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）

7. 【建议】索引列顺序的选择
    - 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数），如列 `user_id` 的区分度可由 `select count(distinct user_id)` 计算出来。
    - 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）
    - 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）

8. 【建议】建表或加索引时，保证表里互相不存在冗余索引。对于 MySQL 来说，如果表里已经存在 `key(a, b)`，则 `key(a)` 为冗余索引，需要删除。

9. 【建议】如果选择性超过 20%，那么全表扫描比使用索引性能更优，即没有设置索引的必要。

10. 【建议】区分度低的列不建议当索引。当索引列有大量数据重复时、SQL查询可能不会去利用索引、如一表中有字段sex、male、female几乎各一半、那么即使在sex上建了索引也对查询效率起不了作用。

11. 【建议】应尽可能的避免更新 clustered 索引数据列、因为 clustered 索引数据列的顺序就是表记录的物理存储顺序、一旦该列值改变将导致整个表记录的顺序的调整、会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列、那么需要考虑是否应将该索引建为 clustered 索引。

12. 【建议】对于频繁的查询优先考虑使用覆盖索引。


### 2.1.7 分库分表、分区表

1. 谨慎使用 `MySQL` 分区表

    - 分区表在物理上表现为多个文件，在逻辑上表现为一个表；
    - 谨慎选择分区键，跨分区查询效率可能更低；
    - 建议采用物理分表的方式管理大数据。

1. 【强制】分区表的分区字段（`partition-key`）必须有索引，或者是组合索引的首列。
2. 【强制】单个分区表中的分区（包括子分区）个数不能超过 1024。
3. 【强制】上线前 RD 或者 DBA 必须指定分区表的创建、清理策略。
4. 【强制】访问分区表的 SQL 必须包含分区键。
5. 【建议】单个分区文件不超过 2G，总大小不超过 50G。建议总分区数不超过 20 个。
6. 【强制】对于分区表执行 `alter table` 操作，必须在业务低峰期执行。
7. 【强制】采用分库策略的，库的数量不能超过 1024。
8. 【强制】采用分表策略的，表的数量不能超过 4096。
9. 【建议】单个分表不超过 500W 行，ibd 文件大小不超过 2G，这样才能让数据分布式变得性能更佳。
10. 【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。


### 2.1.8 字符集

1. 【强制】数据库本身库、表、列所有字符集必须保持一致，为 `utf8` 或 `utf8mb4`。`Collation` 为 `utf8mb4_unicode_ci`，有大小写区别时使用 `utf8mb4_bin`
2. 【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为 `utf8`。


### 2.1.9 程序层 DAO 设计建议

1. 【建议】新的代码不要用 model，推荐使用手动拼 SQL + 绑定变量传入参数的方式。因为 model 虽然可以使用面向对象的方式操作 db，但是其使用不当很容易造成生成的 SQL 非常复杂，且 model 层自己做的强制类型转换性能较差，最终导致数据库性能下降。
2. 【建议】前端程序连接 MySQL 或者 Redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。
3. 【建议】前端程序报错里尽量能够提示 MySQL 或 Redis 原生态的报错信息，便于排查错误。
4. 【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。
5. 【建议】对于 `log` 或 `history` 类型的表，随时间增长容易越来越大，因此上线前 RD 或者 DBA 必须建立表数据清理或归档方案。
6. 【建议】在应用程序设计阶段，RD 必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20 秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。
7. 【建议】多个并发业务逻辑访问同一块数据（InnoDB 表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类 SQL 尽量基于主键去更新。
8. 【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。
9. 【建议】对于单表读写比大于 10:1 的数据行或单个列，可以将热点数据放在缓存里（如 Memcached 或 Redis），加快访问速度，降低 MySQL 压力。


### 2.1.10 一个规范的建表语句示例

- 一个较为规范的建表语句为：
    ```sql
    create table user 
    ( 
        `id`            bigint(11) not null auto_increment, 
        `user_id`       bigint(11) not null comment '用户 ID', 
        `username`      varchar(45) not null comment '登录名', 
        `email`         varchar(30) not null comment '邮箱', 
        `nickname`      varchar(45) not null comment '昵称', 
        `avatar`        int(11) not null comment '头像', 
        `birthday`      date not null comment '生日', 
        `gender`        tinyint(4) default '0' comment '性别', 
        `intro`         varchar(150) default null comment '简介', 
        `resume_url`    varchar(300) not null comment '简历存放地址', 
        `register_ip`   int not null comment '用户注册时的源 IP', 
        `review_status` tinyint not null comment '审核状态，1-通过，2-审核中，3-未通过，4-尚未提交审核', 
        `create_time`   timestamp not null comment '记录创建的时间', 
        `update_time`   timestamp not null comment '资料修改的时间', 
        
        primary key (`id`), 
        unique key `idx_user_id` (`user_id`), 
        key `idx_username`(`username`), 
        key `idx_create_time`(`create_time`, `review_status`) 
    ) 
    engine = InnoDB
    default charset = utf8 
    comment = '用户基本信息'; 
    ```


## 2.2 SQL 编写

### 2.2.1 DML 语句

1. 【强制】select 语句必须指定具体字段名称，禁止写成 `*`。因为 `select *` 会将不该读的数据也从 MySQL 里读出来，造成 I/O 压力。

2. 【强制】insert 语句指定具体字段名称，不要写成 `insert into t1 values(…)`，道理同上。

3. 【建议】`insert into … values(xx),(xx),(xx)…`，这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。

4. 【建议】select 语句不要使用 `union`，推荐使用 `union all`，并且 `union` 子句个数限制在 5 个以内。因为 `union all` 不需要去重，节省数据库资源，提高性能。

5. 【建议】in 值列表限制在 500 以内。例如 `select … where user_id in(…500 个以内…)`，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。

6. 【建议】当只要一行数据时使用 LIMIT 1。当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。

7. 【强制】禁止使用 ORDER BY RAND()
    因为使用 ORDER BY RAND() MySQL会不得 不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）
    ```
    // 千万不要这样做：
    "SELECT username FROM user ORDER BY RAND() LIMIT 1"
     
    // 这要会更好(伪代码)：
    ret = "SELECT count(*) FROM user";
    rand(0, ret [0] - 1);
    "SELECT username FROM user LIMIT $rand, 1";
    ```

8. 【建议】事务里批量更新数据需要控制数量，进行必要的 sleep，做到少量多次。

9. 【强制】事务涉及的表必须全部是 InnoDB 表。否则一旦失败不会全部回滚，且易造成主从库同步终端。

10. 【强制】写入和事务发往主库，只读 SQL 发往从库。

11. 【强制】生产环境禁止使用 `hint`，如 `sql_no_cache`，`force index`，`ignore key`，`straight join` 等。因为 `hint` 是用来强制 sql 按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信 MySQL 优化器。

12. 【建议】在使用索引字段作为条件时、如果该索引是复合索引、那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引、否则该索引将不会被使用、并且应尽可能的让字段顺序与索引顺序相一致。

13. 【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于 100 行以下的静态表可以全表扫描。查询数据量不要超过表行数的 25%，否则不会利用索引。

14. 【建议】分页查询，当 `limit` 起点较高时，可先用过滤条件进行过滤。如 `select a, b, c from t1 limit 10000, 20;` 优化为: `select a, b, c from t1 where id > 10000 limit 20;`。


#### 2.2.1.2 where 子句

1. 【强制】除静态表或小表（100 行以内），dml 语句必须有 where 条件，且使用索引查找。

1. 【强制】where 条件里等号左右字段类型必须一致，否则无法利用索引。

1. 【强制】应尽量避免在 where 子句中对字段进行 null 值判断、否则将导致引擎放弃使用索引而进行全表扫描、如：
    ```
    select id from t where num is null;
    
    # 可以在num上设置默认值0、确保表中num列没有null值、然后这样查询：
    select id from t where num=0;
    ```

2. 【强制】应尽量避免在 where 子句中使用!=或<>操作符、否则将引擎放弃使用索引而进行全表扫描。

3. 【强制】应尽量避免在 where 子句中使用 or 来连接条件、否则将导致引擎放弃使用索引而进行全表扫描、如：
    ```
    select id from t where num=10 or num=20
    
    -- 可以这样查询：
    select id from t where num=10 union all select id from t where num=20;
    ```

4. 【强制】应尽量避免在 where 子句中使用 in 和 not in 、否则会导致全表扫描、如：
    ```
    select id from t where num in(1,2,3);
    ```
    对于连续的数值、能用 between 就不要用 in 了：
    ```
    select id from t where num between 1 and 3;
    ```

5. 【强制】应尽量避免在 where 子句中使用全模糊查找，比如 like %abc%
    ```
    select id from t where name like '%abc%';
    
    --若要提高效率、可以考虑全文检索。
    ```

6. 【强制】如果在 where 子句中使用参数、也会导致全表扫描。因为SQL只有在运行时才会解析局部变量、但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而、如果在编译时建立访问计划、变量的值还是未知的、因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
    ```
    select id from t where num=@num
    
    --可以改为强制查询使用索引：
    select id from t with(index(索引名)) where num= @num ;
    ```

7. 【强制】应尽量避免在 where 子句中对字段进行表达式操作、函数操作和算术运算，这将导致引擎放弃使用索引而进行全表扫描。如：
    ```
    select id from t where num/2=100;
    select id from t where substring(name,1,3)='abc';  --name以abc开头的id
    select id from t where datediff(day,createdate,'2005-11-30')=0;  --‘2005-11-30’生成的id
    
    --应改为:
    
    select id from t where num=100\*2;
    select id from t where name like 'abc%';
    select id from t where createdate>='2005-11-30' and createdate<'2005-12-1';
    ```


### 2.2.2 多表连接

1. 【强制】禁止跨 DB 的 join 语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。
2. 【强制】禁止在业务的更新类 SQL 语句中使用 join，比如 `update t1, t2 where t1.id = t2.id …`。
3. 【建议】不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询，或使用 join 来代替子查询。
4. 【建议】线上环境，多表 join 不要超过 3 个表。
5. 【建议】多表连接查询推荐使用别名，且 select 列表中要用别名引用字段，数据库.表格式，如 `select a from db1.table1 alias1 where …`。
6. 【建议】在多表 join 中，尽量选取结果集较小的表作为驱动表，来 join 其它表。


### 2.2.3 事务

1. 【建议】事务中 `insert|update|delete|replace` 语句操作的行数控制在 2000 以内，以及 where 子句中 in 列表的传参个数控制在 500 以内。
2. 【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的 sleep，一般建议值 5-10 秒。
3. 【建议】对于有 `auto_increment` 属性字段的表的插入操作，并发需要控制在 200 以内。
4. 【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为 `repeatable-read`。
5. 【建议】事务里包含 SQL 不超过 5 个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL 内部缓存、连接消耗过多等雪崩问题。
6. 【建议】事务里更新语句尽量基于主键或 `unique key`，如 `update … where id = XX;`，否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。
7. 【建议】尽量把一些典型外部调用移出事务，如调用 Web Service，访问文件存储等，从而避免事务过长。
8. 【建议】对于 MySQL 主从延迟严格敏感的 select 语句，请开启事务强制访问主库。


### 2.2.4 排序和分组

1. 【建议】减少使用 `order by`，和业务沟通能不排序就不排序，或将排序放到程序端去做。`order by`、`group by`、`distinct` 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。
2. 【建议】`order by`、`group by`、`distinct` 这些 SQL 尽量利用索引直接检索出排序好的数据。如 `where a = 1 order by` 可以利用 `key(a, b)`。
3. 【建议】包含了 `order by`、`group by`、`distinct` 这些查询的语句，where 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。


### 2.2.5 线上禁止使用的 SQL 语句

1. 【高危】禁用 `update|delete t1 … where a = XX limit XX; ` 这种带 limit 的更新语句。因为会导致主从不一致，导致数据错乱。建议加上 `order by PK`。
2. 【高危】禁止使用关联子查询，如 `update t1 set … where name in(select name from user where …);`，效率极其低下。
   【异议】
    其实这个规范对老版本的 MySQL 来说是对的，因为之前版本的 MySQL 数据库对子查询优化有限，所以很多 OLTP 业务场合下，我们都要求在线业务尽可能不用子查询。
    然而，MySQL 8.0 版本中，子查询的优化得到大幅提升，所以在新版本的 MySQL 中可以放心的使用子查询。
    子查询相比 join 更易于人类理解，比如想查看 2020 年没有发过文章的用户的数量：
    ```sql
    -- 使用子查询（逻辑非常清晰）：
    select count(*)
    from user
    where id not in (
       select user_id
       from blog
       where publish_time >= "2020-01-01" and publish_time <= "2020-12-31"
    )
    
    -- 使用 left join（不容易理解）：
    select count(*)
    from user left join blog
    on user.id = blog.user_id and blog.publish_time >= "2020-01-01" and blog.publish_time <= "2020-12-31"
    where blog.user_id is null;
    ```
3. 【强制】禁用 procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。
4. 【强制】禁用 `insert into … on duplicate key update …` 在高并发环境下，会造成主从不一致。


**[⬆ 返回目录](#mysql-数据库设计规范)**


### 临时表和游标

3. 【建议】尽量使用表变量来代替临时表。如果表变量包含大量数据、请注意索引非常有限（只有主键索引）。

3. 【建议】避免频繁创建和删除临时表、以减少系统表资源的消耗。

3. 【建议】临时表并不是不可使用、适当地使用它们可以使某些例程更有效、例如、当需要重复引用大型表或常用表中的某个数据集时。但是、对于一次性事件、最好使用导出表。

3. 【建议】在新建临时表时、如果一次性插入数据量很大、那么可以使用 select into 代替 create table、避免造成大量 log 、以提高速度；如果数据量不大、为了缓和系统表的资源、应先create table、然后insert。

3. 【建议】如果使用到了临时表、在存储过程的最后务必将所有的临时表显式删除、先 truncate table 、然后 drop table 、这样可以避免系统表的较长时间锁定。

3. 【建议】尽量避免使用游标、因为游标的效率较差、如果游标操作的数据超过1万行、那么就应该考虑改写。

3. 【建议】使用基于游标的方法或临时表方法之前、应先寻找基于集的解决方案来解决问题、基于集的方法通常更有效。

3. 【建议】与临时表一样、游标并不是不可使用。对小型数据集使用 FAST\_FORWARD 游标通常要优于其他逐行处理方法、尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许、基于游标的方法和基于集的方法都可以尝试一下、看哪一种方法的效果更好。

3. 【建议】在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON 、在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE\_IN\_PROC 消息。


### 其他的一些建议

1. 固定长度的表会更快

如果表中的所有字段都是“固定长度”的，整个表会被认为是[“static” 或 “fixed-length”](http://dev.MySQL.com/doc/refman/5.1/en/static-format.html)。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。

固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。

并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。

可以使用“垂直分割”技术，分割你的表成为两个一个是定长的，一个则是不定长的。

2. 垂直分割

“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过 一张表有100多个字段，很恐怖）

示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个 人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有 好的性能。

示例二：你有一个叫 “last\_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户 ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。

另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。


3. 越小的列会越快

对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。

参看 MySQL 的文档 [Storage Requirements](http://dev.MySQL.com/doc/refman/5.0/en/storage-requirements.html) 查看所有的数据类型。

如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。

当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看[Slashdot 的例子](http://news.slashdot.org/article.pl?sid=06/11/09/1534204) （2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。

4. 减少同数据库的交互次数

5. 拆分复杂的大 `SQL` 为多个小 `SQL`。尽量避免大事务操作、提高系统并发能力。

6. 尽量避免向客户端返回大数据量、若数据量过大、应该考虑相应需求是否合理。

1. 为查询缓存优化你的查询

大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样后续的相同的查询就不用操作表而直接访问缓存结果了。这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：

```
// 查询缓存不开启
"SELECT username FROM user WHERE signup_date >= CURDATE()"
 
// 开启查询缓存
$today=date("Y-m-d");
"SELECT username FROM user WHERE signup_date >= '$today'";
```

上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。

2\. EXPLAIN 你的 SELECT 查询

EXPLAIN 博客[https://blog.csdn.net/fenglepeng/article/details/103392319](https://blog.csdn.net/fenglepeng/article/details/103392319)

使用 [EXPLAIN](http://dev.MySQL.com/doc/refman/5.0/en/explain.html) 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。

EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等。